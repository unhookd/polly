#!/usr/bin/env ruby

$executing_as = File.basename($0)
$polly_dir = File.dirname(File.dirname(File.realpath(__FILE__)))

lib = File.join($polly_dir, "lib")
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require 'polly'

class PollyTasks < Thor
  desc "changelog [CHANGELOG]", "appends changelog item to CHANGELOG.md"
  def changelog(changelog = "CHANGELOG.md")
    exe = Polly::Execute.new

    Dir.chdir(ENV['PWD'])

    existing_entries = File.exists?(changelog) ? File.read(changelog).split("\n").collect { |l| l.strip } : []

    version_delim = "#######"
    version_count = existing_entries.count { |l| l.include?(version_delim) }

    today = Date.today.to_s
    username = IO.popen("git config user.name").read.strip || ENV["USER"] || "ac"
    template_args = [today, username]
    version = "#{File.exists?('VERSION.major') ? File.read('VERSION.major').strip : 1}.#{version_count + 1}.0"
    opening_line_template = "# [#{version}] - %s - %s\n\n\n\n#{version_delim}\n" % template_args

    Tempfile.create(changelog) do |new_entry_tmp|
      new_entry_tmp.write(opening_line_template)
      new_entry_tmp.rewind

      if exe.system("vi", new_entry_tmp.path)
        new_entry = File.read(new_entry_tmp.path).split("\n").collect { |l| l.strip }

        if new_entry.length > 0
          new_entry << ""

          existing_entries.unshift(*new_entry)
          existing_entries << ""

          File.write("VERSION", version)
          File.write(changelog, existing_entries.join("\n"))
        end
      end
    end

    exe.systemx("git", "add", changelog, "VERSION")
    exe.systemx("git", "commit", "--allow-empty", "-m", "updates in #{changelog}")
  end

  desc "version", "Print version"
  def version
    version = File.read(File.expand_path("../VERSION", __dir__)).strip
    obv = ::Polly::Observe.new
    obv.register_channels([::Polly::POLLY])
    obv.report_stdout(::Polly::POLLY, version)
    obv.flush($stdout, $stderr, true)
  end

  desc "tcr", "TBD: some sort of re-conceptulization of a TCR + kube build"
  def tcr
    #TODO
    #
    # watch files
    #  run command based on pattern match of filename and Pollyfile case switch
    #
    #require "rubygems"
    #require "bundler/setup"
    #require "guard"
    #require "guard/cli"

    #Guard::Cli::Environments::Valid.new({}).start_guard

    #inner_dsl = Guard::Dsl.new
    #dsl = Guard::RSpec::Dsl.new(inner_dsl)
    #rspec = dsl.rspec
    #inner_dsl.guard :rspec, cmd: "bundle exec rspec" do
    #  inner_dsl.watch(rspec.spec_helper) { rspec.spec_dir }
    #  ##watch(rspec.spec_support) { rspec.spec_dir }
    #  ##watch(rspec.spec_files)

    #  ## Ruby files
    #  #ruby = dsl.ruby
    #  #dsl.watch_spec_files_for(ruby.lib_files)
    #end
  end

  desc "gitch [FEATURE]", "git commit utilities"
  option "i", :type => :boolean, :default => false
  option "u", :type => :boolean, :default => false
  option "m", :type => :string, :default => nil
  option "y", :type => :boolean, :default => false
  def gitch(feature = nil)
    exe = ::Polly::Execute.new

    if feature
      if exe.system("git", "checkout", "-b", feature)
      else
        exe.systemx("git", "checkout", feature)
        exit(0)
      end
    end

    if options["i"] === true
      if exe.systemx("git", "init")
        exit(0)
      end
    end

    if options["u"]
      if exe.systemx("git", "push", "-u", options["u"], "HEAD")
        exit(0)
      end
    end

    if msg = options["m"]
      if exe.systemx("git", "add", ".")
        if exe.systemx("git", "commit", "-m", (msg.length > 1) ? msg : "wip")
          exit(0)
        end
      end
    end

    if options["y"]
      #TODO: `git add -y . && git commit -y -m 'yolo' && git push -f -u -y origin master`
    end
  end

  desc "continuous", ""
  option "config", :type => :string, :default => "Pollyfile", :desc => "Declaration of config"
  option "exec", :type => :boolean, :default => false
  def continuous
    config = options["config"]

    #TODO: switch plan based on detected hueristics here
    if File.exists?(config)
      pollyfile_ruby = File.read(config)
      Kernel.eval(pollyfile_ruby, Polly::Generate.get_binding, config)
      cmd_list = Polly::Generate.read_shell_commands
      puts cmd_list

      if options["exec"]
        exec(*cmd_list)
      end
    end
  end

  desc "test [PIPELINE]", "Run the CI pipeline"
  option "concurrency", :type => :numeric, :default => Polly::Plan::DEFAULT_CONCURRENCY, :desc => "Number of divergent paths to process simultaneously"
  option "config", :type => :string, :default => "Pollyfile", :desc => "Declaration of config"
  option "with-bootstrap", :type => :string, :default => nil, :desc => "Docker image to use as the build context"
  option "dry-run", :type => :boolean, :default => false, :desc => "Emit the plan but do not run the pipeline"
  option "keep-completed", :type => :boolean, :default => false, :desc => "Retain completed pods in kubectl get pods list"
  option "detach-failed", :type => :boolean, :default => false, :desc => "Keep failed pods running"
  option "debug", :type => :boolean, :default => false, :desc => "Show debug output"
  option "short-circuit", :type => :boolean, :default => false, :desc => "Halt workflow on first failure"
  option "skip", :type => :string, :default => nil, :desc => "Don't run specified jobs (comma-separated list)"
  option "only", :type => :string, :default => nil, :desc => "Only run specified jobs (comma-separated list)"
  option "no-init", :type => :boolean, :default => false, :desc => "Do not run pod initialization (eg git-checkout container) before each job (this can speed up debug looping)"
  option "ident", :type => :string, :default => nil, :desc => "todo"
  def test(run_pipeline_upto_these_jobs = nil)
    start_time = Time.now

    exe = ::Polly::Execute.new(options)
    revision = exe.current_revision

    plan = ::Polly::Plan.new(revision, run_pipeline_upto_these_jobs, options)

    obv = ::Polly::Observe.new

    obv.register_channels(["debug", "plan", "exe"])

    config = options["config"]

    #TODO: switch plan based on detected hueristics here
    if File.exists?(config)
      #obv.report_stdout("debug", "using #{config} for config")
      if config.include?("Pollyfile")
        pollyfile_ruby = File.read(config)
        Kernel.eval(pollyfile_ruby, Polly::Generate.get_binding, config)
        generated_circleci_config_yml = YAML.dump(Polly::Generate.read_circleci_output(options["ident"]))
        plan.load_circleci(generated_circleci_config_yml)
      else
        plan.load_circleci(File.read(config))
      end
    elsif File.exists?(".circleci/config.yml")
      plan.load_circleci(File.read(".circleci/config.yml"))
    else
      raise "must create #{config} first ..."
    end

    obv.register_channels(plan.all_jobs.collect { |key, _| key })

    #obv.report_stdout("plan", plan.description)
    #obv.report_stdout("exe", exe.description)

    while exe.running? || plan.has_unfinished_jobs?
      #$stderr.write("!")
      #started_this_loop = []

      plan.jobs_ready_to_start.each do |job_proc|
        job_to_start = job_proc.call
        
        obv.report_stdout("plan", "started #{job_to_start.run_name}")
        obv.flush($stdout, $stderr)
        exe.start_job!(job_to_start)
        break
      end

      #$stderr.write("@")
      #unless started_this_loop.empty?
      #  obv.report_stdout("plan", "started #{started_this_loop.collect(&:run_name)}")
      #end

      #$stderr.write("#")
      finished_this_loop, io_this_loop = exe.wait_for_jobs_to_finish
      
      #$stderr.write("$")
      finished_this_loop.collect do |finished_job|
        plan.complete_job!(finished_job)
        finished_job
      end

      #$stderr.write("%")
      #NOTE, sort ordering of parallell observation channels arent supported, flush needed twice
      io_this_loop.each do |job_run_name, stdout, stderr|
        obv.report_io(job_run_name, stdout, stderr)
      end
      obv.flush($stdout, $stderr)

      #$stderr.write("^")
      unless finished_this_loop.empty?
        ran_failed, ran_ok = finished_this_loop.partition { |j| j.failed? }
        obv.report_stdout("plan", "finished #{ran_ok.collect(&:run_name)}") unless ran_ok.empty?
        obv.report_stderr("plan", "failed #{ran_failed.collect(&:run_name)}") unless ran_failed.empty?
      end
      obv.flush($stdout, $stderr)
    end

    cleanup_all_ok = exe.wait_for_cleanup

    duration = Time.now - start_time

    if cleanup_all_ok
      obv.report_stdout("plan", "all jobs ok... #{duration}s")
    else
      obv.report_stdout("plan", "some jobs failed... #{duration}s")
    end

    obv.flush($stdout, $stderr, true)

    exit cleanup_all_ok
  end

  desc "push [BRANCH]", "Push the latest commit into the Polly container"
  option "local", :type => :boolean, :default => false
  def push(branch = nil)
    exe = ::Polly::Execute.new

    branch ||= exe.current_branch

    #override_json = Proc.new { |args|
    #  json = JSON.parse(File.read("config/polly-bootstrap.json"))
    #  json["spec"]["containers"][0]["args"] = args
    #  JSON.dump(json)
    #}

    #bootstrap_init_cmd = [
    #  "kubectl", "run", "-i", "--rm", "polly-bootstrap",
    #  "--image=alpine/git:latest",
    #  #"--overrides", override_json.call(["init", "--bare", "/polly-safe/git/#{exe.current_app}"]), 
    #  "--overrides", override_json.call(["-c", "git init --bare /polly-safe/git/#{exe.current_app}"]),
    #  "--restart=Never"
    #]
    #
    ##"init", "--bare", "/polly-safe/git/#{exe.current_app}"
    ##]

    #exe.systemx(*bootstrap_init_cmd)
    #
    #bootstrap_recv_pack = [
    #  "git", "push", "-f", "polly", branch, "--exec=#{$polly_dir}/bin/polly receive-pack"
    #]

    #exe.systemx(*bootstrap_recv_pack)

    #unless exe.polly_pod
    #  git_repo_template_install_cmd = [
    #                   "kubectl", "cp", 
    #                   File.join($polly_dir, "config/git-repo/templates"),
    #                   "#{exe.polly_pod}:/usr/share/git-core/"
    #                 ]
    #  exe.systemx(*git_repo_template_install_cmd)
    #end

    # /polly-safe/app/config/git-repo/templates
    # File.join($polly_dir, "config/git-repo/templates")

    #TODO: specify the remote follow branch with a toggle possibly???
    exe.systemx("git", "push", "-f", "polly", branch, "HEAD:#{branch}-#{Time.now.to_i}", "--exec=polly receive-pack#{options['local'] ? " --local" : ""}")

    #TODO:
    #####cat /var/tmp/polly-safe/buildkit/example-510b1e33549a9f97b9fce43f1a30d13afe208390.tar | docker import - example:latest
    ####cat_image_cmd = [
    ####                 "kubectl", "exec", exe.polly_pod,
    ####                 "--",
    ####                 "cat", "/polly-safe/buildkit/#{exe.current_app}-#{exe.current_revision}.tar"
    ####               ]
    ####docker_tag_cmd = [
    ####                  "docker",
    ####                  "import",
    ####                  "-",
    ####                  "#{exe.current_app}:latest"
    ####               ]
    #####options = {:stdin_data => docker_config_secret.join}
    #####o,e,s = exe.execute_simple(:output, apply_job, options)
    #####puts [o, e]
    ####status_list = Open3.pipeline(cat_image_cmd, docker_tag_cmd)
  end

  desc "receive-pack [ORIGIN]", "(internal) receive incoming git send-pack"
  option "bootstrap", :type => :boolean, :default => false
  option "local", :type => :boolean, :default => false
  long_desc <<-LONGDESC
    Internal command, invoked via polly push.

    Polly hosts an internal git repo, in a persistent volume mounted to the running polly container.

    This is essentially a git remote that receives the incoming git send-pack, which is forwarded on by polly receive-pack.

    For more information, see https://git-scm.com/docs/git-receive-pack
  LONGDESC
  def receive_pack(origin = nil)
    exe = ::Polly::Execute.new

    git_init_cmd = [
                     "git", "init", "--bare", "/polly/safe/git/#{exe.current_app}",
                     "--template=/polly/app/config/git-repo/templates"
                   ]

    unless options["local"]
      git_init_cmd = [
                       "kubectl", "exec", exe.polly_pod,
                       "-i",
                       "--",
                       *git_init_cmd
                     ]
    end

    o,e,s = exe.execute_simple(:output, git_init_cmd, {})
    puts o
    unless s
      puts e
      exit(1)
    end
    exe.wait_child

    git_rp_cmd = [
                   "git", "receive-pack", "/polly/safe/git/#{exe.current_app}"
                 ]

    unless options["local"]
      # exe.polly_pod

      git_rp_cmd = [
                     "kubectl", "exec", exe.polly_pod,
                     "-i",
                     "--",
                     *git_rp_cmd
                   ]
    end

    #git_push_cmd = [
    #  "kubectl", "run", "-i", "--rm", "polly-bootstrap",
    #  "--overrides", File.read("config/polly-bootstrap.json"), "--image=alpine/git:latest",
    #  "--restart=Never", "--",
    #  "receive-pack", "/polly-safe/git/#{exe.current_app}"
    #]

    #override_json = Proc.new { |args|
    #  json = JSON.parse(File.read("config/polly-bootstrap.json"))
    #  json["spec"]["containers"][0]["args"] = args
    #  JSON.dump(json)
    #}

    #git_push_cmd = [
    #  "kubectl", "run", "--quiet", "-i", "--rm", "polly-bootstrap",
    #  "--image=alpine/git:latest",
    #  "--overrides", override_json.call(["-I", "-c", "sleep 10 && exec git receive-pack /polly-safe/git/#{exe.current_app}"]),
    #  "--restart=Never"
    #]
    #
    ##"--env=GIT_TRACE_PACKET=true",

    exec(*git_rp_cmd)

    options = {:stdin_data => $stdin.read}
    #o,e,s = exe.execute_simple(:output, git_rp_cmd, options)
    #exe.wait_child
    #unless s
    #  puts [o, e]
    #  exit(1)
    #end
  end

  desc "build [container_def]", "Build the current working directory's Dockerfile"
  #? option "run", :type => :string, :default => nil
  #? option "push", :type => :string, :default => nil
  option "cache", :type => :boolean, :default => true
  option "explain", :type => :boolean, :default => false
  option "in-cluster", :type => :boolean, :default => false
  def build(container_definition=nil)
    default_pollyfile = "Pollyfile"
    default_dockerfile = "Dockerfile"

    exe = ::Polly::Execute.new(options)

    version = exe.current_revision
    branch = exe.current_branch.gsub("/", "-")
    app = exe.current_app
    image_repo = Polly::Config.image_repo

    generated_dockerfile = nil

    if (container_definition == nil || container_definition == "-" || container_definition == default_pollyfile) && File.exists?(default_pollyfile)
      pollyfile_ruby = File.read(default_pollyfile)
      #TODO: ??? Polly::Generate.options = options
      Kernel.eval(pollyfile_ruby, Polly::Generate.get_binding, default_pollyfile)
      generated_dockerfile = Polly::Generate.read_output
    elsif (container_definition == "-" || container_definition == default_dockerfile) && File.exists?(default_dockerfile)
      #generated_dockerfile = File.read(default_dockerfile)
      raise if version.empty?
      Polly::Build.buildkit_workstation_to_controller(exe, app, branch, version, options["no-cache"])
      exit
    #elsif container_definition == nil && File.exists?(default_dockerfile)
    #  generated_dockerfile = File.read(default_dockerfile)
    else
      generated_dockerfile = File.read(container_definition)
    end

    if options["in-cluster"]
      Polly::Generate.all_images.each { |build_image|
        Polly::Build.buildkit_internal(exe, app, build_image, version, generated_dockerfile, options["no-cache"])
      }
    else
      raise if version.empty?
      Polly::Build.buildkit_external(exe, app, branch, version, generated_dockerfile, options["no-cache"])
    end

    raise if version.empty?

    Polly::Build.buildkit_workstation_to_controller(exe, app, "wkndr", version, generated_dockerfile, options["no-cache"])

    exit

    #if container_definition == "-" && File.exists?(default_pollyfile)
    #  pollyfile_ruby = File.read(default_pollyfile)
    #  #TODO: ??? Polly::Generate.options = options
    #  Kernel.eval(pollyfile_ruby, Polly::Generate.get_binding, default_pollyfile)
    #  generated_dockerfile = Polly::Generate.read_output
    #elsif container_definition == "-" && File.exists?(default_dockerfile)
    #  #generated_dockerfile = File.read(default_dockerfile)
    #else
    #  generated_dockerfile = File.read(container_definition)
    #  sub_version = container_definition.split(".").last
    #  if sub_version != container_definition
    #    app += "-" + sub_version
    #  end
    #end

    ##if options["in-cluster"]
    ##  Polly::Generate.all_images.each { |build_image|
    ##    Polly::Build.buildkit_internal(exe, app, build_image, version, generated_dockerfile, options["no-cache"])
    ##  }
    ##else
    ##  raise if version.empty?
    ##  Polly::Build.buildkit_external(exe, app, "wkndr", version, generated_dockerfile, options["no-cache"])
    ##end
  end

#  desc "checkout [REPO] [VERSION] [DESTINATION]", ""
#  def checkout(repo, version, destination)
#    obv = ::Polly::Observe.new
#    obv.register_channels(["checkout"])
#
#    exe = ::Polly::Execute.new
#
#    exe.systemx("mkdir", "-p", destination)
#    obv.report_stdout("checkout", "mkdir #{destination}")
#    obv.flush($stdout, $stderr, true)
#
#    #TODO: implement locking as an option
#    polly_lock = "#{File.dirname(destination)}/.polly.lock"
#
#    File.open(polly_lock, File::RDWR|File::CREAT, 0644) { |f|
#      obv.report_stdout("checkout", "aquired lock")
#      obv.flush($stdout, $stderr, true)
#
#      f.flock(File::LOCK_EX)
#      if Dir.chdir(destination)
#        obv.report_stdout("checkout", "checking for repo")
#        obv.flush($stdout, $stderr, true)
#
#        if exe.execute_simple(:silent, ["git", "status"], {})
#          obv.report_stdout("checkout", "found repo")
#          obv.flush($stdout, $stderr, true)
#        else
#          obv.report_stdout("checkout", "... not found, creating now")
#          obv.flush($stdout, $stderr, true)
#          exe.systemx("git", "init")
#        end
#
#        exe.execute_simple(:silent, ["git", "remote", "add", "origin", repo], {})
#        obv.report_stdout("checkout", "installed remote")
#        obv.flush($stdout, $stderr, true)
#
#        exe.execute_simple(:silentx, ["git","fetch", "origin"], {})
#        obv.report_stdout("checkout", "fetched origin")
#
#        #TODO: implement caching option/flag
#        exe.execute_simple(:silentx, ["git", "clean", "-f"], {})
#        obv.report_stdout("checkout", "cleaned repo")
#
#        #exe.systemx("git", "reset")
#        #exe.systemx("git", "checkout", "--", ".")
#        exe.execute_simple(:silentx, ["git", "checkout", "-m", version], {})
#        obv.report_stdout("checkout", "checkedout #{version}")
#
#        exe.systemx("chmod", "-R", "777", File.dirname(destination))
#        #exe.systemx("chown", "-R", "1000", File.dirname(destination))
#        obv.report_stdout("checkout", "chowned #{destination}")
#      end
#    }
#
#    obv.flush($stdout, $stderr, true)
#  end

  desc "certificates [CNAME]", "installs some common ca certificate secret material into cluster"
  option "namespace", :type => :string, :default => "default"
  option "mode", :type => :string, :default => "directory"
#  def certificates(inbound_ssh_key="", inbound_ssh_key_pub="", cname = "polly-registry", cname_two = "0.0.0.0")
#    # openssl pkcs12 -export -in server.crt -inkey server.key -out server.p12
#    inbound_ssh_key = File.read(inbound_ssh_key) unless inbound_ssh_key.empty?
#    inbound_ssh_key_pub = File.read(inbound_ssh_key_pub) unless inbound_ssh_key_pub.empty?
  def certificates(cnames = "polly.local")
    #inbound_ssh_key = File.read(inbound_ssh_key) unless inbound_ssh_key.empty?
    #inbound_ssh_key_pub = File.read(inbound_ssh_key_pub) unless inbound_ssh_key_pub.empty?
    #TODO: openssl pkcs12 -export -in server.crt -inkey server.key -out server.p12
    #
    key_client = OpenSSL::PKey::RSA.new 4096

    key = OpenSSL::PKey::RSA.new 4096
    key_dsa = OpenSSL::PKey::DSA.new 4096

    #TODO
    #ssh_key = StringIO.new
    #ssh_key.write(key.ssh_type)
    #ssh_key.write([key.to_blob.length].pack('N'))
    #ssh_key.write(key.to_blob)
    #ssh_priv_key = ssh_key.string

    type = key_client.ssh_type
    data2 = [ key_client.to_blob ].pack('m0')
    openssh_format = "#{type} #{data2}"

    data = key.to_pem
    data_dsa = key_dsa.to_pem

    exe = ::Polly::Execute.new

    root_key = OpenSSL::PKey::RSA.new 2048 # the CA's public/private key #!!!!!!

    root_ca = OpenSSL::X509::Certificate.new
    root_ca.version = 2 # cf. RFC 5280 - to make it a "v3" certificate
    root_ca.serial = 1
    root_ca.subject = OpenSSL::X509::Name.parse "/DC=org/DC=unhookd/CN=POLLYCA"
    root_ca.issuer = root_ca.subject # root CA's are "self-signed"
    root_ca.public_key = root_key.public_key
    root_ca.not_before = Time.now
    root_ca.not_after = root_ca.not_before + 2 * 365 * 24 * 60 * 60 # 2 years validity

    ef = OpenSSL::X509::ExtensionFactory.new
    ef.subject_certificate = root_ca
    ef.issuer_certificate = root_ca
    root_ca.add_extension(ef.create_extension("basicConstraints","CA:TRUE",true))
    root_ca.add_extension(ef.create_extension("keyUsage","keyCertSign, cRLSign", true))
    root_ca.add_extension(ef.create_extension("subjectKeyIdentifier","hash",false))
    root_ca.add_extension(ef.create_extension("authorityKeyIdentifier","keyid:always",false))
    root_ca.sign(root_key, OpenSSL::Digest::SHA256.new)

    cnames = cnames.split(":") + ["polly-registry"]
    cname = cnames.first

    key = OpenSSL::PKey::RSA.new 2048
    cert = OpenSSL::X509::Certificate.new
    cert.version = 2
    cert.serial = 2
    cert.subject = OpenSSL::X509::Name.parse "/DC=org/DC=unhookd/CN=#{cname}"
    cert.issuer = root_ca.subject # root CA is the issuer
    cert.public_key = key.public_key
    cert.not_before = Time.now
    cert.not_after = cert.not_before + 2 * 365 * 24 * 60 * 60 # 2 years validity
    ef = OpenSSL::X509::ExtensionFactory.new
    ef.subject_certificate = cert
    ef.issuer_certificate = root_ca
    cert.add_extension(ef.create_extension("keyUsage", "digitalSignature", true))
    cert.add_extension(ef.create_extension("subjectKeyIdentifier", "hash", false))
    cert.add_extension(ef.create_extension("subjectAltName", cnames.collect { |cn| "DNS:#{cn}" }.join(",") + ",IP:0.0.0.0", false))
    cert.sign(root_key, OpenSSL::Digest::SHA256.new)

    key2 = OpenSSL::PKey::RSA.new 2048
    cert2 = OpenSSL::X509::Certificate.new
    cert2.version = 2
    cert2.serial = 2
    cert2.subject = OpenSSL::X509::Name.parse "/DC=org/DC=unhookd/CN=polly-buildkitd"
    cert2.issuer = root_ca.subject # root CA is the issuer
    cert2.public_key = key2.public_key
    cert2.not_before = Time.now
    cert2.not_after = cert2.not_before + 2 * 365 * 24 * 60 * 60 # 2 years validity
    ef = OpenSSL::X509::ExtensionFactory.new
    ef.subject_certificate = cert2
    ef.issuer_certificate = root_ca
    cert2.add_extension(ef.create_extension("keyUsage", "digitalSignature", true))
    cert2.add_extension(ef.create_extension("subjectKeyIdentifier", "hash", false))
    cert2.add_extension(ef.create_extension("subjectAltName", "DNS:polly-buildkitd,IP:127.0.0.1", false))
    cert2.sign(root_key, OpenSSL::Digest::SHA256.new)

    key3 = OpenSSL::PKey::RSA.new 2048
    cert3 = OpenSSL::X509::Certificate.new
    cert3.version = 2
    cert3.serial = 2
    cert3.subject = OpenSSL::X509::Name.parse "/DC=org/DC=unhookd/CN=polly-buildctl"
    cert3.issuer = root_ca.subject # root CA is the issuer
    cert3.public_key = key3.public_key
    cert3.not_before = Time.now
    cert3.not_after = cert3.not_before + 2 * 365 * 24 * 60 * 60 # 2 years validity
    ef = OpenSSL::X509::ExtensionFactory.new
    ef.subject_certificate = cert3
    ef.issuer_certificate = root_ca
    cert3.add_extension(ef.create_extension("keyUsage", "digitalSignature", true))
    cert3.sign(root_key, OpenSSL::Digest::SHA256.new)

    #key = File.read("/usr/local/etc/openssl/misc/workstation-key.pem")
    #cert = File.read("/usr/local/etc/openssl/misc/workstation-cert.pem")

    workstation_ca_certificates = "/etc/ssl/certs/ca-certificates.crt"
    wca = File.read(workstation_ca_certificates)

    a = wca
    b = root_ca.to_pem
    c = wca + root_ca.to_pem

    #blob = [key.public_key.to_s].pack("m*").gsub(/\s/, "")
    #blob = [Net::SSH::Buffer.from(:raw, key.public_key.to_der).to_s].pack("m*").gsub(/\s/, "")
    #known_hosts = "wkstation-service ssh-rsa #{blob}"
    #fff = Net::SSH::HostKeyEntries::PubKey.new(key.public_key.der)
    #puts fff.inspect
    #FileUtils.rm("/var/tmp/cheese.known_hosts")
    #kn = Net::SSH::KnownHosts.new("/var/tmp/cheese.known_hosts")
    #kn.add("wkstation-service", key)
    #known_hosts = File.read("/var/tmp/cheese.known_hosts")
    #puts known_hosts.inspect
    #TODO: !!!
    #ssh_key: #{Base64.strict_encode64(inbound_ssh_key || "")}
    #ssh_key_pub: #{Base64.strict_encode64(inbound_ssh_key_pub || "")}


    case options["mode"]
      when "k8s-secrets"
        polly_certificates = <<-HEREDOC
---
apiVersion: v1
kind: Secret
metadata:
  name: sshd
type: Opaque
data:
  rsa: #{Base64.strict_encode64(data)}
  dsa: #{Base64.strict_encode64(data_dsa)}
  dsa_pub: #{Base64.strict_encode64(key_dsa.public_key.to_s)}
  rsa_pub: #{Base64.strict_encode64(key.public_key.to_s)}
...
#---
#apiVersion: v1
#kind: Secret
#metadata:
#  name: "registry-certificates"
#type: Opaque
#data:
#  registry.polly.pem: #{Base64.strict_encode64(cert.to_pem)}
#  registry.polly.key: #{Base64.strict_encode64(key.to_pem)}
#  name: sshd
#type: Opaque
#data:
#  rsa: #{Base64.strict_encode64(data)}
#  dsa: #{Base64.strict_encode64(data_dsa)}
#  dsa_pub: #{Base64.strict_encode64(key_dsa.public_key.to_s)}
#  rsa_pub: #{Base64.strict_encode64(key.public_key.to_s)}
#...
##---
##apiVersion: v1
##kind: Secret
##metadata:
##  name: "registry-certificates"
##type: Opaque
##data:
##  registry.polly.pem: #{Base64.strict_encode64(cert.to_pem)}
##  registry.polly.key: #{Base64.strict_encode64(key.to_pem)}
##...
##---
##apiVersion: v1
##kind: Secret
##metadata:
##  name: "ca-certificates"
##type: Opaque
##data:
##  ca.workstation.crt: #{Base64.strict_encode64(a)}
##  ca.polly.crt: #{Base64.strict_encode64(b)}
##  ca-certificates.crt: #{Base64.strict_encode64(c)}
##...
#---
#apiVersion: v1
#kind: Secret
#metadata:
#  name: "buildkit-daemon-certs"
#type: Opaque
#data:
#  ca.pem: #{Base64.strict_encode64(b)}
#  cert.pem: #{Base64.strict_encode64(cert2.to_pem)}
#  key.pem: #{Base64.strict_encode64(key2.to_pem)}
#...
#---
#apiVersion: v1
#kind: Secret
#metadata:
<<<<<<< HEAD
#  name: "ca-certificates"
#type: Opaque
#data:
#  ca.workstation.crt: #{Base64.strict_encode64(a)}
#  ca.polly.crt: #{Base64.strict_encode64(b)}
#  ca-certificates.crt: #{Base64.strict_encode64(c)}
#...
HEREDOC

      obv = ::Polly::Observe.new
      obv.register_channels(["certificates"])

      delete_polly_certificates = ["kubectl", "delete", "--namespace=#{options['namespace']}", "-f", "-"]
      create_polly_certificates = ["kubectl", "create", "--namespace=#{options['namespace']}", "-f", "-"]

      options = {:stdin_data => polly_certificates}
      o,e,s = exe.execute_simple(:output, delete_polly_certificates, options)
      obv.report_io("certificates", o, e)
      obv.flush($stdout, $stderr)

      o,e,s = exe.execute_simple(:output, create_polly_certificates, options)
      obv.report_io("certificates", o, e)
      obv.flush($stdout, $stderr)

      obv.flush($stdout, $stderr, true)

#  name: "buildkit-client-certs"
#type: Opaque
#data:
#  ca.pem: #{Base64.strict_encode64(b)}
#  cert.pem: #{Base64.strict_encode64(cert3.to_pem)}
#  key.pem: #{Base64.strict_encode64(key3.to_pem)}
#...
#HEREDOC
#
#      obv = ::Polly::Observe.new
#      obv.register_channels(["certificates"])
#
#      delete_polly_certificates = ["kubectl", "delete", "--namespace=#{options['namespace']}", "-f", "-"]
#      create_polly_certificates = ["kubectl", "create", "--namespace=#{options['namespace']}", "-f", "-"]
#
#      options = {:stdin_data => polly_certificates}
#      o,e,s = exe.execute_simple(:output, delete_polly_certificates, options)
#      obv.report_io("certificates", o, e)
#      obv.flush($stdout, $stderr)
#
#      o,e,s = exe.execute_simple(:output, create_polly_certificates, options)
#      obv.report_io("certificates", o, e)
#      obv.flush($stdout, $stderr)
#
#      obv.flush($stdout, $stderr, true)
#

    when "directory"
      dir = File.join("/var/tmp", SecureRandom.uuid)
      FileUtils.mkdir_p(dir)

      File.umask(0077)

      File.write("#{dir}/id_rsa.pub", openssh_format)
      File.write("#{dir}/id_rsa", key_client.to_s)

      File.write("#{dir}/web-server-certificate.pem", cert)
      File.write("#{dir}/web-server-key.pem", key)

      #TODO: sort out certificate-stack documentation
      File.write("#{dir}/etc_slash_ssh_slash_ssh_host_rsa_key", key)
      exe.ssh_private_key_from_rsa_private_key("#{dir}/etc_slash_ssh_slash_ssh_host_rsa_key")
      File.write("#{dir}/etc_slash_ssh_slash_ssh_host_rsa_key.pub", exe.ssh_keygen_from_private_key("#{dir}/etc_slash_ssh_slash_ssh_host_rsa_key"))

      File.write("#{dir}/from-workstation-ca.crt", a)
      File.write("#{dir}/polly-root-ca.crt", b)
      File.write("#{dir}/multipass-mega.crt", c)

      File.write("#{dir}/buildkit-server-cert.crt", cert2)
      File.write("#{dir}/buildkit-server-cert.key", key2)

      File.write("#{dir}/buildkit-client-cert.crt", cert3)
      File.write("#{dir}/buildkit-client-cert.key", key3)

      #TODO: link with vertical.yaml specification
      puts "certificates will be found in #{dir}"
    end
  end

  desc "init [CERTS]", "bootstraps project polly controller pod"
  option "re-init", :type => :boolean, :default => false
  option "with-registry", :type => :boolean, :default => false
  option "with-bootstrap", :type => :string, :default => "ghcr.io/unhookd/polly:3.0-rc1" # "polly:3.0-rc1"
  def init(cert_package_dir)
    exe = ::Polly::Execute.new

    unless exe.in_polly?
      $stderr.puts "... halting, init only for polly"
      Kernel.exit(1)
    end

    polly_resources = []
    polly_services = []
    polly_deployments = []
    polly_pvcs = []

    #polly_image = "#{exe.current_app}:#{exe.current_revision}"
    #polly_command = ["polly", "dev", "/var/lib/polly/Procfile.init", "--rename=polly-init"].to_json
    #apache2: /usr/sbin/apache2 -D FOREGROUND
    #nginx-apt-proxy: /usr/sbin/nginx -g 'daemon off;'

    git_image = options["with-bootstrap"] # "alpine/git:latest"
    git_command = ["sleep", "2147483647"].to_json

    #etc_slash_ssh_slash_ssh_host_rsa_key
    #etc_slash_ssh_slash_ssh_host_rsa_key.pub
    #from-workstation-ca.crt
    #id_rsa.pub
    #multipass-mega.crt
    #polly-root-ca.crt
    #web-server-certificate.pem
    #web-server-key.pem
    #File.write("#{dir}/web-server-certificate.pem", cert)
    #File.write("#{dir}/web-server-key.pem", key)
    #File.write("#{dir}/from-workstation-ca.crt", a)
    #File.write("#{dir}/polly-root-ca.crt", b)
    #File.write("#{dir}/multipass-mega.crt", c)
    #
    a = File.open(File.join(cert_package_dir, "from-workstation-ca.crt")).read
    b = File.open(File.join(cert_package_dir, "polly-root-ca.crt")).read
    c = File.open(File.join(cert_package_dir, "multipass-mega.crt")).read

    cert = File.open(File.join(cert_package_dir, "web-server-certificate.pem")).read
    key = File.open(File.join(cert_package_dir, "web-server-key.pem")).read

    key2 = File.open(File.join(cert_package_dir, "buildkit-server-cert.key")).read
    cert2 = File.open(File.join(cert_package_dir, "buildkit-server-cert.crt")).read
    key3 = File.open(File.join(cert_package_dir, "buildkit-client-cert.key")).read
    cert3 = File.open(File.join(cert_package_dir, "buildkit-client-cert.crt")).read

#---
#apiVersion: v1
#kind: Secret
#metadata:
#  name: sshd
#type: Opaque
#data:
#  rsa: #{Base64.strict_encode64(data)}
#  dsa: #{Base64.strict_encode64(data_dsa)}
#  dsa_pub: #{Base64.strict_encode64(key_dsa.public_key.to_s)}
#  rsa_pub: #{Base64.strict_encode64(key.public_key.to_s)}
#...
    polly_certificates = <<-HEREDOC
---
apiVersion: v1
kind: Secret
metadata:
  name: "registry-certificates"
type: Opaque
data:
  registry.polly.pem: #{Base64.strict_encode64(cert)}
  registry.polly.key: #{Base64.strict_encode64(key)}
...
---
apiVersion: v1
kind: Secret
metadata:
  name: "ca-certificates"
type: Opaque
data:
  ca.workstation.crt: #{Base64.strict_encode64(a)}
  ca.polly.crt: #{Base64.strict_encode64(b)}
...
---
apiVersion: v1
kind: Secret
metadata:
  name: "buildkit-daemon-certs"
type: Opaque
data:
  ca.pem: #{Base64.strict_encode64(b)}
  cert.pem: #{Base64.strict_encode64(cert2)}
  key.pem: #{Base64.strict_encode64(key2)}
...
---
apiVersion: v1
kind: Secret
metadata:
  name: "buildkit-client-certs"
type: Opaque
data:
  ca.pem: #{Base64.strict_encode64(b)}
  cert.pem: #{Base64.strict_encode64(cert3)}
  key.pem: #{Base64.strict_encode64(key3)}
...
HEREDOC

#puts polly_certificates
#exit

    #  obv = ::Polly::Observe.new
    #  obv.register_channels(["certificates"])

    #  delete_polly_certificates = ["kubectl", "delete", "--namespace=#{options['namespace']}", "-f", "-"]
    #  create_polly_certificates = ["kubectl", "create", "--namespace=#{options['namespace']}", "-f", "-"]

    #  options = {:stdin_data => polly_certificates}
    #  o,e,s = exe.execute_simple(:output, delete_polly_certificates, options)
    #  obv.report_io("certificates", o, e)
    #  obv.flush($stdout, $stderr)

    #  o,e,s = exe.execute_simple(:output, create_polly_certificates, options)
    #  obv.report_io("certificates", o, e)
    #  obv.flush($stdout, $stderr)

    #  obv.flush($stdout, $stderr, true)

    polly_resources << polly_certificates << <<-HEREDOC
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: polly
  namespace: default
...
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: polly
  namespace: default
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
...
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: polly-bindings
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: polly
subjects:
- kind: ServiceAccount
  name: polly
  namespace: default
...
HEREDOC

    polly_pvcs << <<-HEREDOC
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  annotations:
  labels:
    stack: polly
  name: polly-mount
spec:
  accessModes:
  - ReadWriteMany
  resources:
    requests:
      storage: 5Gi
  storageClassName: local-path
...
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: polly-mount
  labels:
    stack: polly
spec:
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteMany
  storageClassName: local-path
  hostPath:
    path: /var/tmp/polly-safe
...
HEREDOC

    polly_services << <<-HEREDOC
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: buildkitd
  name: polly-buildkitd
spec:
  ports:
    - port: 1234
      protocol: TCP
  selector:
    app: buildkitd
...
HEREDOC

#    polly_services << <<-HEREDOC
#---
#apiVersion: v1
#kind: Service
#metadata:
#  name: "polly-headless"
#spec:
#  clusterIP: "None"
#  ports:
#  - port: 8111
#    name: nginx-apt-proxy
#    protocol: TCP
#  - port: 8080
#    name: apache2
#    protocol: TCP
#  - port: 5000
#    name: docker-registry
#    protocol: TCP
#  selector:
#    name: "polly-app"
#...
#HEREDOC

#    polly_services << <<-HEREDOC
#---
#apiVersion: v1
#kind: Service
#metadata:
#  name: "polly-app"
#spec:
#  ports:
#  - port: 8111
#    name: nginx-apt-proxy
#    protocol: TCP
#  - port: 8080
#    name: apache2
#    protocol: TCP
#  selector:
#    name: "polly-app"
#...
#HEREDOC

    if options["with-registry"]
      polly_services << <<-HEREDOC
---
apiVersion: v1
kind: Service
metadata:
  name: "polly-registry"
spec:
  ports:
  - port: 23443
    targetPort: 23443
    name: https
    protocol: TCP
  selector:
    name: "polly-registry"
...
HEREDOC
    end

#    polly_services << <<-HEREDOC
#---
#apiVersion: v1
#kind: Service
#metadata:
#  name: "polly-app-node"
#spec:
#  type: NodePort
#  ports:
#  - port: 5000
#    nodePort: 31500
#    name: docker-registry-node
#    protocol: TCP
#  selector:
#    name: "polly-app"
#...
#HEREDOC

    polly_deployments << <<-HEREDOC
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: polly-buildkitd-configuration
data:
  buildkitd.toml: |-
    debug = true
    [registry."polly-registry:23443"]
    ca=["/certs/ca.polly.crt"]
    insecure = true
...
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: buildkitd
    stack: polly
  name: polly-buildkitd
spec:
  serviceName: polly-buildkitd
  replicas: 1
  podManagementPolicy: Parallel
  selector:
    matchLabels:
      app: buildkitd
  template:
    metadata:
      labels:
        name: polly-buildkitd
        app: buildkitd
        stack: polly
      annotations:
        container.apparmor.security.beta.kubernetes.io/buildkitd: unconfined
        container.seccomp.security.alpha.kubernetes.io/buildkitd: unconfined
    spec:
      terminationGracePeriodSeconds: 180
      containers:
#####<<<<<<< HEAD
        - name: buildkitd
          image: moby/buildkit:master-rootless
          args:
            - --oci-worker-no-process-sandbox
          readinessProbe:
            exec:
              command:
                - buildctl
                - debug
                - workers
            initialDelaySeconds: 5
            periodSeconds: 30
          livenessProbe:
            exec:
              command:
                - buildctl
                - debug
                - workers
            initialDelaySeconds: 5
            periodSeconds: 30
          securityContext:
            # Needs Kubernetes >= 1.19
            seccompProfile:
              type: Unconfined
            # To change UID/GID, you need to rebuild the image
            runAsUser: 1000
            runAsGroup: 1000
          volumeMounts:
          # Dockerfile has `VOLUME /home/user/.local/share/buildkit` by default too,
          # but the default VOLUME does not work with rootless on Google's Container-Optimized OS
          # as it is mounted with `nosuid,nodev`.
          # https://github.com/moby/buildkit/issues/879#issuecomment-1240347038
          - mountPath: /home/user/.local/share/buildkit
            name: buildkitd
          - name: configurations
            subPath: buildkitd.toml
            mountPath: /home/user/.config/buildkit/buildkitd.toml
          - name: ca-certificates
            mountPath: /certs
      volumes:
      - name: buildkitd
        emptyDir: {}
      - name: configurations
        configMap:
          name: polly-buildkitd-configuration
      - name: ca-certificates
        secret:
          secretName: ca-certificates
####=======
#      - name: buildkitd
#        image: moby/buildkit:master-rootless
#        resources:
#          requests:
#            memory: 10Mi
#            cpu: 10m
#          limits:
#            memory: 12000Mi
#        args:
#        - --addr
#        - tcp://0.0.0.0:1234
#        - --tlscacert
#        - /certs/server/ca.pem
#        - --tlscert
#        - /certs/server/cert.pem
#        - --tlskey
#        - /certs/server/key.pem
#        - --oci-worker=true
#        - --oci-worker-rootless=true
#        - --oci-worker-no-process-sandbox=true
#        - --oci-worker-gc=true
#        - --oci-worker-gc-keepstorage=20000
#        - --oci-worker-snapshotter=overlayfs
#        readinessProbe:
#          exec:
#            command:
#            - buildctl
#            - --addr
#            - tcp://127.0.0.1:1234
#            - --tlscacert
#            - /certs/client/ca.pem
#            - --tlscert
#            - /certs/client/cert.pem
#            - --tlskey
#            - /certs/client/key.pem
#            - debug
#            - workers
#          initialDelaySeconds: 30
#          periodSeconds: 60
#          successThreshold: 1
#          failureThreshold: 16
#          timeoutSeconds: 30
#        livenessProbe:
#          exec:
#            command:
#            - buildctl
#            - --addr
#            - tcp://127.0.0.1:1234
#            - --tlscacert
#            - /certs/client/ca.pem
#            - --tlscert
#            - /certs/client/cert.pem
#            - --tlskey
#            - /certs/client/key.pem
#            - debug
#            - workers
#          initialDelaySeconds: 30
#          periodSeconds: 60
#          successThreshold: 1
#          failureThreshold: 16
#          timeoutSeconds: 30
#        securityContext:
#          runAsUser: 1000
#          runAsGroup: 1000
#        ports:
#        - containerPort: 1234
#        volumeMounts:
#        - name: "share-dir"
#          mountPath: /home/user/.local/share/buildkit
#        - name: buildkit-daemon-certs
#          readOnly: true
#          mountPath: /certs/server
#        - name: buildkit-client-certs
#          readOnly: true
#          mountPath: /certs/client
#      securityContext:
#        fsGroup: 1000
#      volumes:
#      - name: buildkit-daemon-certs
#        secret:
#          secretName: buildkit-daemon-certs
#      - name: buildkit-client-certs
#        secret:
#          secretName: buildkit-client-certs
#      - name: share-dir
#        emptyDir: {}
...
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: polly-controller
  labels:
    app: polly-controller
    stack: polly
spec:
  revisionHistoryLimit: 1
  strategy:
    type: Recreate
  replicas: 1
  selector:
    matchLabels:
      name: polly-controller
  template:
    metadata:
      labels:
        name: polly-controller
        stack: polly
    spec:
      serviceAccountName: polly
      volumes:
      - name: buildkit-client-certs
        secret:
          secretName: buildkit-client-certs
      - name: polly-mount
        persistentVolumeClaim:
          claimName: polly-mount
      - name: registry-certificates
        secret:
          secretName: registry-certificates
      securityContext:
        runAsUser: 1000
        fsGroup: 1000
        #supplementalGroups: [121, 123, 134, 999, 1000, 1001]
      initContainers:
      containers:
      - name: polly-controller
        securityContext:
          runAsUser: 1000
        volumeMounts:
        - mountPath: /polly/safe
          name: polly-mount
        - mountPath: /etc/ssl/private
          name: registry-certificates
          readOnly: true
        - mountPath: /certs/client
          name: buildkit-client-certs
          readOnly: true
        image: #{git_image}
        imagePullPolicy: IfNotPresent
        env:
        resources:
          requests:
            memory: 500Mi
            cpu: 10m
          limits:
            memory: 8000Mi
            cpu: 5000m
        command: #{git_command}
...
HEREDOC

    if options["with-registry"]
      polly_deployments << <<-HEREDOC
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: registry-config
data:
  registry.conf: |
    version: 0.1
    storage:
      filesystem:
        rootdirectory: /polly/safe/registry
...
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: polly-registry
  labels:
    app: polly-registry
    stack: polly
spec:
  revisionHistoryLimit: 1
  strategy:
    type: Recreate
  replicas: 1
  selector:
    matchLabels:
      name: polly-registry
  template:
    metadata:
      labels:
        name: polly-registry
        stack: polly
    spec:
      hostNetwork: true
      volumes:
        - name: registry-config
          configMap:
            name: registry-config
        - name: polly-mount
          persistentVolumeClaim:
            claimName: polly-mount
        - name: registry-certificates
          secret:
            secretName: registry-certificates
      initContainers:
      containers:
      - name: polly-registry
        volumeMounts:
          - mountPath: /polly/safe
            name: polly-mount
          - mountPath: /etc/ssl/private
            name: registry-certificates
            readOnly: true
          - mountPath: /registry.conf
            subPath: registry.conf
            name: registry-config
        image: registry:2
        imagePullPolicy: IfNotPresent
        resources:
          requests:
            memory: 500Mi
            cpu: 500m
          limits:
            memory: 1000Mi
            cpu: 2000m
        ports:
        - containerPort: 23443
          name: https
        command:
        - /bin/registry
        args:
        - serve
        - /registry.conf
        env:
        - name: REGISTRY_HTTP_TLS_CERTIFICATE
          value: /etc/ssl/private/registry.polly.pem
        - name: REGISTRY_HTTP_TLS_KEY
          value: /etc/ssl/private/registry.polly.key
        - name: REGISTRY_HTTP_ADDR
          value: 0.0.0.0:23443
...
HEREDOC
    end

    polly_run = polly_resources.join + polly_pvcs.join + polly_services.join + polly_deployments.join

    if options["re-init"]
      deploy_polly_app = ["kubectl", "delete", "-f", "-"]
      options = {:stdin_data => polly_run}
      o,e,s = exe.execute_simple(:output, deploy_polly_app, options)
      puts [o, e, s]

      wait_polly_app_deleted = ["kubectl", "wait", "--for=delete", "pod", "-l", "stack=polly"]
      o,e,s = exe.execute_simple(:output, wait_polly_app_deleted, {})
      puts [o, e, s]
    end

    deploy_polly_app = ["kubectl", "apply", "--server-side=true", "-f", "-"]
    options = {:stdin_data => polly_run}

    o,e,s = exe.execute_simple(:output, deploy_polly_app, options)
    puts [o, e, s]

    wait_polly_app = ["kubectl", "wait", "--for=condition=available", "deployment/polly-controller"]
    o,e,s = exe.execute_simple(:output, wait_polly_app, {})
    puts [o, e, s]

    wait_polly_app = ["kubectl", "rollout", "status", "deployment/polly-controller"]
    o,e,s = exe.execute_simple(:output, wait_polly_app, {})
    puts [o, e, s]
  end

  desc "xxh", "debug shell into polly controller"
  def xxh(service = "git", sh_cmd = "sh")
    exe = ::Polly::Execute.new

    exec(*["kubectl", "exec", exe.polly_pod(service), "-i", $stdin.tty? ? "-t" : nil, "--", sh_cmd].compact)
  end

  desc "shr", "run a polly shell"
  def shr(shr_cmd = "bash")
    exe = ::Polly::Execute.new

    exec(*["kubectl", "run", "shr", "-it", "--pod-running-timeout=3m0s", "--image=ghcr.io/unhookd/polly:master", "--image-pull-policy=IfNotPresent", "--rm=true", "--quiet=true", "--", shr_cmd].compact)
  end

  desc "rxn", "run app pod"
  option "stage", :type => :string, :default => nil
  def rxn(rxn_cmd = "bash")
    exe = ::Polly::Execute.new

    environment_overrides = nil
    if File.exist?("vertical.yaml")
      vertical_lookup = YAML.load(File.read("vertical.yaml"))
      environment_overrides = vertical_lookup["environment-overrides"]
    end

    env_flags = (environment_overrides || []).collect { |env| "--env=#{env["name"]}=#{env["value"]}" }

    version = exe.current_revision
    branch = exe.current_branch
    app = exe.current_app
    image_repo = Polly::Config.image_repo

    tag = Polly::Build.build_image_to_tag(app, options["stage"] || branch, version)
    #tag = Polly::Build.build_image_to_tag(app, "wkndr", version)
    puts tag.inspect

    cmd = ["kubectl", "run", "rxn-#{app}", "--attach=true", "-it", "--pod-running-timeout=3m0s", *env_flags, "--image=polly-registry:23443/polly-registry/#{tag}", "--image-pull-policy=Always", "--rm=true", "--quiet=true", "--", rxn_cmd].compact
    #      cmd = ["kubectl", "run", "rxn", "--attach=true", "-it", "--pod-running-timeout=3m0s", *env_flags, "--image=polly-registry:23443/polly-registry/#{tag}", "--image-pull-policy=Always", "--rm=true", "--quiet=true", "--command", "--", rxn_cmd].compact
    puts cmd.inspect

    exec(*cmd)
  end

  desc "wxh", "workstation instance"
  def wxh(profile)
    exe = ::Polly::Execute.new

    exec("ssh", "-AX", "app@#{exe.multipass_ip(profile)}")
  end

  desc "waitx", "TBD: wait for pod availability, execute subsequent command"
  def waitx(clean_name, *cmd)
    exe = ::Polly::Execute.new

    #$stderr.write("waiting for deploy\n")
    exe.execute_simple(:silent, ["kubectl", "wait", "--for=condition=available", "deployment/#{clean_name}"], {})

    #$stderr.write("listing pods\n")
    find_all_pods = "kubectl get pods -l name=#{clean_name} -o name | cut -d/ -f2"
    a = IO.popen(find_all_pods).read.strip
    exe.wait_child
    all_pods = a.split("\n")

    pod_index = 0
    kube_exec_cmd = [
                     "kubectl", "exec",
                     all_pods[pod_index],
                     "--"
                    ] + cmd

    o,e,s = exe.execute_simple(:output, kube_exec_cmd, {})
    #TODO
    puts [e, e, s] unless s
  end

  desc "logs", "fetch logs from polly controller pod"
  def logs
    exe = ::Polly::Execute.new
    exec(*["kubectl", "logs", exe.polly_pod, "-f"].compact)
  end

  desc "dev [PROCFILE]", "runs processes as outlined in Procfile"
  option "prepare", :type => :boolean, :default => false
  option "only-prepare", :type => :boolean, :default => false
  option "rename", :type => :string
  def dev(procfile = "Procfile")
    exe = ::Polly::Execute.new

    if options["rename"]
      exe.rename(options["rename"])
    end

    if (options["prepare"] || options["only-prepare"])
      if File.exists("Prepfile")
        prepfile_lines = File.readlines(prepfile)
        exe.execute_procfile(ENV['PWD'], prepfile_lines)
      end
    end

    unless options["only-prepare"]
      if File.exists?(procfile)
        procfile_lines = File.readlines(procfile)
        exe.execute_procfile(ENV['PWD'], procfile_lines)
      end
    end
  end

  desc "generate", "emits CI structure yaml"
  option "mirror", :type => :string, :default => "dockerfile"
  #TODO: cleanup these bits
  #option "pipeline-fu", :type => :string, :default => "circleci"
  #option "image-fu", :type => :string, :default => "buildkit"
  option "bootstrap", :type => :string, :default => "pollyfile" #TODO
  def generate(pollyfile = "Pollyfile")
    obv = ::Polly::Observe.new
    exe = ::Polly::Execute.new(options)

    pollyfile_ruby = File.read(pollyfile)

    Kernel.eval(pollyfile_ruby, Polly::Generate.get_binding, pollyfile)

    case options["mirror"]
      when "circleci"
        pollyfile_ruby = File.read("Pollyfile")
        Kernel.eval(pollyfile_ruby, Polly::Generate.get_binding, "Pollyfile")
        generated_circleci_config_yml = YAML.dump(Polly::Generate.read_circleci_output)
        $stdout.write(generated_circleci_config_yml)

      when "github"
        #TODO: re-emit githubrc file

      when "dockerfile"
        $stdout.write(Polly::Generate.read_output)
    else
      $stderr.puts "unknown option #{options.inspect}"
    end
  end

  desc "vertical [WORKFLOW]", "emit kubernetes resources for a simple job based CI"
  option "reset", :type => :boolean, :default => false
  option "build", :type => :boolean, :default => false
  option "create", :type => :boolean, :default => false
  option "generate", :type => :boolean, :default => false
  option "retry", :type => :string, :default => nil
  def vertical(workflow = "default")
    exe = ::Polly::Execute.new
    current_sha = exe.current_revision
    current_app = exe.current_app

    max_ci = ENV['MAX_CI'] || "1"
    maxv = (ENV['MAXV'] || 2).to_i
    total_nodes = (ENV['TOTAL_NODES'] || 1).to_i

    job_verticals = []
    vertical_index = 0
    db_index = 0

    vertical_lookup = YAML.load(File.read("vertical.yaml"))
    repo_registry = vertical_lookup["repo-registry"]
    namespace = vertical_lookup["namespace"] || "default"

    service_layer_shards = vertical_lookup["service-layer-shards"]
    service_layer_decorate_envs = vertical_lookup["service-layer-decorate-envs"]

    default_image = "#{repo_registry}:#{current_sha}"

    if options["retry"]
      default_image += "-#{options["retry"]}"
    end

    all_jobs_yaml = ""

    exec_lookup = vertical_lookup["vertical-stacks"][workflow]

    offset = 0

    exec_lookup.each { |container_name, container_lookup|
      image = container_lookup["image"] || default_image
      init_command = container_lookup["init"]
      exec_command = container_lookup["exec"]
      maxv_inner = container_lookup["maxv"] || maxv
      maxv_allowed = container_lookup["maximize"] ? maxv_inner : 1

      vertical_env = [
        {
          "name" => "MAX_CI",
          "value" => max_ci
        },
        {
          "name" => "CI_SHA1",
          "value" => current_sha
        },
      ] + vertical_lookup["environment-overrides"]

      count_this_pod = 0
      this_chunk = 0
      stack_index = 0

      containers = []

      first_expandeded_foo = nil

      maxv_allowed.times { |i|
        expanded_vertical_env = []

        vertical_env.each { |kvo|
          if service_layer_shards && service_layer_decorate_envs.include?(kvo["name"])
            service_shard = i % service_layer_shards

            existing_uri = URI.parse(kvo["value"])

            host = (kvo["value"])
            scheme = ""
            port = ""
            begin
              if url_host = existing_uri.host
                host = url_host
                scheme = existing_uri.scheme + "://"
                if existing_uri.port
                  port = ":#{existing_uri.port}"
                end
              end
            rescue URI::BadURIError => e
            end

            expanded_vertical_env << {
              "name" => kvo["name"],
              "value" => scheme + host + "-" + service_shard.to_s + "." + host + port
            }
          else
            expanded_vertical_env << kvo
          end
        }

        containers << {
          "name" => "#{current_app}-#{container_name}-#{i}",
          "image" => image,
          "imagePullPolicy" => "IfNotPresent",
          "command" => exec_command,
          "volumeMounts" => vertical_lookup["volume-mounts"],
          "resources" => {
            "requests" => {
              "cpu" => "250m",
              "memory" => "500m"
            },
            "limits" => {
              "cpu" => "8000m",
              "memory" => "10.0G"
            }
          },
          "env" => expanded_vertical_env + [
            {
              "name" => "MAXV",
              "value" => maxv_allowed.to_s
            },
            {
              "name" => "TEST_ENV_NUMBER",
              "value" => ((offset * maxv) + i).to_s
            },
          ]
        }

        if i == 0
          first_expandeded_foo = expanded_vertical_env
        end

        db_index += 1
      }

      this_index = 0

      max_per_pod = maxv_allowed > 1 ? (containers.length / total_nodes).ceil : maxv_allowed

      until containers.empty?
        containers_this_pod = containers.shift(max_per_pod)
        raise "wtf #{max_per_pod} #{containers.length}" if containers_this_pod.empty?

        init_containers = []

        if init_command
          init_containers << {
            "name" => "init-#{container_name}",
            "image" => image,
            "imagePullPolicy" => "IfNotPresent",
            "command" => init_command,
            "volumeMounts" => vertical_lookup["volume-mounts"],
            "resources" => {
              "requests" => {
                "cpu" => "1000m",
                "memory" => "400m"
              },
              "limits" => {
                "cpu" => "4000m",
                "memory" => "8.0G"
              }
            },
            "env" => first_expandeded_foo + [
              {
                "name" => "MAXV",
                "value" => 1.to_s # needs to be 0th
              },
              {
                "name" => "TEST_ENV_NUMBER",
                "value" => ((offset * maxv) + stack_index).to_s # needs to be 0th
              },
              #{
              #  "name" => "VERTICAL_DB",
              #  "value" => container_name.gsub(/[^a-z0-9]/, '_') + stack_index.to_s
              #},
              #{
              #  "name" => "VERTICAL_DB_INDEX",
              #  "value" => db_index.to_s
              #},
	          ]
          }

          db_index += 1
        end

        job_vertical = {
          "apiVersion" => "batch/v1",
          "kind" => "Job",
          "metadata" => {
            "name" => "#{current_app}-#{container_name}-#{this_index}-#{current_sha[0...5]}",
            "annotations" => {
            }
          },
          "spec" => {
            "backoffLimit" => 0,
            "template" => {
              "metadata" => {
                "labels" => {
                  "pipeline" => "vertical-ci",
                  "vertical" => container_name
                }
              },
              "spec" => {
                "restartPolicy" => "Never",
                "initContainers" => init_containers,
                "containers" => containers_this_pod,
                "nodeSelector" => vertical_lookup["node-selector"],
                "tolerations" => vertical_lookup["tolerations"],
                "volumes" => vertical_lookup["volumes"],
                "hostAliases" => vertical_lookup["host-aliases"]
              }
            }
          }
        }

        all_jobs_yaml += YAML.dump(job_vertical)

        this_index += 1
      end

      stack_index += 1

      vertical_index += 1
      offset += 1
    }

    #TODO: tbd if this is needed
    if options["build"]
      buildctl_local_cmd = [
        "buildctl",
        "--addr", "kube-pod://polly-buildkitd-0?namespace=#{namespace}",
        "build",
        "--ssh", "default=#{Dir.home}/.ssh/id_rsa",
        "--frontend", "dockerfile.v0",
        "--local", "context=.", "--local", "dockerfile=.",
        "--output", "type=image,name=#{default_image},push=true"
      ]

      system(*buildctl_local_cmd) || fail("unable to build")
    end

    if options["reset"]
      delete_vertical_ci = ["kubectl", "delete", "--namespace", namespace, "jobs", "-l", "pipeline=vertical-ci"]
      delete_options = {}
      o,e,s = exe.execute_simple(:output, delete_vertical_ci, delete_options)
      puts [o, e, s]
    end

    if options["generate"]
      puts all_jobs_yaml
    end

    if options["create"]
      create_vertical_ci = ["kubectl", "create", "--namespace", namespace, "-f", "-"]
      create_options = {:stdin_data => all_jobs_yaml}
      o,e,s = exe.execute_simple(:output, create_vertical_ci, create_options)
      puts [o, e]
    end
  end

  ##TODO: re-impl without /usr/bin/docker
  ##mkdir -p ~/.docker
  ##kubectl create secret docker-registry --dry-run=client docker-regcred \
  ##  --docker-server=XXX/repo \
  ##  --docker-username=AWS \
  ##  --docker-password=${PASSWORD} \
  ##  --namespace=xxx \
  ##  -o json | jq -r '.data.".dockerconfigjson"' | base64 -d > ~/.docker/config.json
  #desc "login [REPO]", "utility to authenticate to docker repo"
  #def login(repo_registry_url = nil)
  #  exe = ::Polly::Execute.new
  #  vertical_lookup = YAML.load(File.read("vertical.yaml"))
  #  repo_registry = vertical_lookup["repo-registry"]

  #  docker_login_password = IO.popen("aws ecr get-login-password").read
  #  Process.wait
  #  unless $?.success?
  #    exit(1)
  #  end

  #  docker_login_cmd = ["docker", "login", "--username", "AWS", "--password-stdin", repo_registry]
  #  options = {:stdin_data => docker_login_password}
  #  o,e,s = exe.execute_simple(:output, docker_login_cmd, options)
  #  puts [o, e, s]
  #end

  desc "launch [PROFILE]", "todo"
  option "debug", :default => false, :type => :boolean
  option "automatic-host-key", :default => false, :type => :boolean
  def launch(profile = "foo")
    exe = ::Polly::Execute.new

    vertical_lookup = YAML.load(File.read("vertical.yaml"))
    station_profile = vertical_lookup["platforms"][profile]

    station_profile.each { |platform, params|
      case platform
        when "multipass"
          #TODO: pattern-matching ruby3x jazz
          raise unless (distro = params["distro"]) && (ssh = params["ssh"]) &&
                         (client_key_pub = ssh["client_key_pub"]) &&
                         (server_key = ssh["server_key"]) &&
                         (server_key_pub = ssh["server_key_pub"]) &&
                         (ca_cert = ssh["ca_cert"])

          cloud_init_yaml = ::Polly::Build.build_cloudinit_yaml(exe, vertical_lookup, File.read(ca_cert), File.read(client_key_pub), File.read(server_key), File.read(server_key_pub))

          if options["debug"]
            puts cloud_init_yaml
            exit
          end

          known_hosts_file = File.expand_path("~/.ssh/known_hosts")
          known_hosts = File.read(known_hosts_file) if File.exists?(known_hosts_file)

          multipass_launch_cmd = ["multipass", "launch", "--name", profile, "--disk=100G", "--cpus=4", "--memory=10G", "--cloud-init=-", distro]
          multipass_options = {:out => $stdout, :err => $stderr, :in => ::Polly::Build.generated_string_fd(cloud_init_yaml)}
          exe.system({}, *multipass_launch_cmd, multipass_options)

          server_key_pub_pem = File.read(server_key_pub)
          known_hosts_line = "#{exe.multipass_ip(profile)} #{server_key_pub_pem}"

          if known_hosts && known_hosts.index(known_hosts_line)
          else
            if options["automatic-host-key"] || yes?("append #{known_hosts_file}?")
              # echo $(ruby devstack/wkip.rb threep) $(ssh-keygen -yf tmp/threep/sshd_rsa_key) > ~/.ssh/known_hosts
              File.write(known_hosts_file, (known_hosts || "") + "\n" + known_hosts_line + "\n")
            end
          end

      end
    }

  end

  desc "stationkeep [PROFILE]", "todo"
  def stationkeep(profile = "foo", substation = nil)
    exe = ::Polly::Execute.new

    vertical_lookup = YAML.load(File.read("vertical.yaml"))
    stationkeeps = vertical_lookup["stationkeeps"]

    multipass_ip = exe.multipass_ip(profile)

    if substation
      stationkeeps = stationkeeps.select { |stationkeep| stationkeep["name"] == substation }
    end

    stationkeeps.each { |stationkeep|
      sudo = false
      if bootstrap = stationkeep["root"]
        sudo = true
      elsif bootstrap = stationkeep["app"]
      else
        raise
      end

      bootstrap_script = File.read(bootstrap)
      shebang = bootstrap_script.split("\n")[0].split("!", 2)[1].split(" ")

      options = {:stdin_data => bootstrap_script}
      ssh_pipe = ["ssh", "-AX", "app@#{multipass_ip}", sudo ? "sudo" : nil, *shebang].compact
      stdin, stdout, stderr, wait_thr = Open3.popen3(*ssh_pipe)
      stdin.write(options[:stdin_data])
      stdin.close

      resolution = :ok
      begin
        until wait_thr.join(1.0 / 24.0)
          if bits = begin
                      stdout.readpartial(8192)
                    rescue EOFError
                    end

            $stdout.write(bits)
          end
        end
      rescue Interrupt
        Process.kill("INT", wait_thr.pid)
        $stderr.write(stderr.read)
        resolution = :interrupt
      end

      $stdout.write(stdout.read) unless stdout.eof?
      #$stderr.write(stderr.read) unless stderr.eof?

      unless wait_thr.value.success?
        puts wait_thr.value.inspect
        puts stderr.read
        resolution = :errored
      end

      break unless resolution == :ok
    }

    puts
    puts "... all installers have run to completion"
  end

  desc "mkhooks [PROFILE]", "todo"
  option "user", :type => :string, :default => "app", :desc => "todo"
  def mkhooks(profile = "foo")
    exe = ::Polly::Execute.new

    multipass_ip = exe.multipass_ip(profile)
    uuid = SecureRandom.uuid

    remote_user = options["user"] + "@" + multipass_ip

    if system("git", "remote", "add", profile, "#{remote_user}:workspace/#{uuid}.git")
      system("ssh", remote_user, "--", "mkdir", "-p", "/home/#{options['user']}/workspace") || fail
      system("ssh", remote_user, "--", "mv", "/home/#{options['user']}/workspace/#{File.basename(Dir.pwd)}", "/var/tmp/before-#{uuid}.git", :err => "/dev/null") || true
      system("ssh", remote_user, "--", "git", "config", "--global", "init.defaultBranch", "main") || fail
      system("ssh", remote_user, "--", "git", "init", "--bare", "--shared=group", "/home/#{options['user']}/workspace/#{uuid}.git") || fail
      system("ssh", remote_user, "--", "rm", "-Rf", "/home/#{options['user']}/workspace/#{uuid}.git/hooks") || fail
      system("git", "push", profile, "HEAD")
      system("ssh", remote_user, "--", "git", "clone", "/home/#{options['user']}/workspace/#{uuid}.git", "/home/#{options['user']}/workspace/#{File.basename(Dir.pwd)}", "--branch", `git rev-parse --abbrev-ref HEAD`) || fail
      system("ssh", remote_user, "--", "ln", "-sf", "/home/#{options['user']}/workspace/#{File.basename(Dir.pwd)}/devstack/git-hooks", "/home/#{options['user']}/workspace/#{uuid}.git/hooks")
      system("ssh", remote_user, "--", "git", "-C", "/home/#{options['user']}/workspace/#{uuid}.git config", "receive.advertisePushOptions", "true")

      system("ssh", remote_user, "--", "git", "config", "--global", "user.name", IO.popen("git config user.name").read.strip)
      system("ssh", remote_user, "--", "git", "config", "--global", "user.email", IO.popen("git config user.email").read.strip)

      polly_ssh_config_d = "#{Dir.home}/.ssh/polly_config.d"
      FileUtils.mkdir_p(polly_ssh_config_d)
      File.write(File.join(polly_ssh_config_d, profile), "Host #{multipass_ip}\n  ForwardAgent yes")

      #system("git", "config", "remote.#{profile}.sshCommand", 'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o ForwardAgent=yes -X')
    else
      puts "re-init manually... git remote remove #{profile}"
      #system("ssh", remote_user, "--", "git", "-C", "/home/#{options['user']}/workspace/#{File.basename(Dir.pwd)}", "pull")
      #system("ssh", remote_user, "--", "git", "-C", "/home/#{options['user']}/workspace/#{File.basename(Dir.pwd)}", "show")
      #system("ssh", remote_user, "--", "git", "--git-dir", "/home/#{options['user']}/workspace/#{File.basename(Dir.pwd)}/.git", "pull")
    end
  end

  private

  def fetch_from_registry(path)
    exe = ::Polly::Execute.new

    #registry_label = "name=polly-registry"

    #random_port = 5000 + (rand * 1000).to_i

    #kubectl_port_forward_cmd = [
    #                             "kubectl",
    #                             "port-forward",
    #                             exe.polly_pod(registry_label),
    #                             "#{random_port}:443"
    #                           ]

    #options = {}
    #process_stdin, process_stdout, process_stderr, process_waiter = exe.execute_simple(:async, kubectl_port_forward_cmd, options)

    #process_stdout.expect("-> 443")

    #TODO: ca-certificates
    #"-k",
    #"--cacert",
    #ssl_cert_file,
    #"--resolve",
    #"polly-registry:5000:127.0.0.1",
    #random_port https localhost port forward hacks

    vertical_lookup = YAML.load(File.read("vertical.yaml"))
    repo_registry = vertical_lookup["repo-registry"]

    curl_cmd = [
                         "curl",
                         "-L",
                         "-s",
                         "-v",
                         "-m",
                         "999",
                         "--connect-timeout",
                         "999",
                         "https://#{repo_registry}/#{path}"
                       ]
    puts curl_cmd.inspect

    options = {}
    o,e,s = exe.execute_simple(:output, curl_cmd, options)
    puts [e, s].inspect

    #Process.kill(:INT, process_waiter.pid)
    #process_waiter.kill
    #process_waiter.join
    #exe.wait_child

    o
  end
end

case $executing_as
  when "thor"

  when Polly::POLLY, "Thorfile"
    PollyTasks.start(ARGV)
end

#TODO: kaniko build step
=begin
---
apiVersion: v1
kind: Pod
metadata:
  name: kaniko
spec:
  containers:
  - name: kaniko
    imagePullPolicy: IfNotPresent
    #image: polly:latest
    #command: ["sleep", "infinity"]
    image: gcr.io/kaniko-project/executor:latest
    args: ["--dockerfile", "Dockerfile",
           "--context", "/var/polly/scratch/polly/current",
           "--destination", "polly-app:5000/polly:kaniko-latest",
           "--cache",
           "--cache-dir=/var/polly/cache"]
    volumeMounts:
      - name: polly-sandbox
        mountPath: /var/polly
      - name: ca-certificates
        mountPath: /kaniko/ssl/certs
    env:
      #- name:
      #  value:
  restartPolicy: Never
  volumes:
    - name: ca-certificates
      secret:
        secretName: ca-certificates
    - name: polly-sandbox
      persistentVolumeClaim:
        claimName: polly-sandbox-claim
...
---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: polly-sandbox-claim
  labels:
    stack: polly
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 10Gi
  storageClassName: local-storage
...
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: polly-sandbox
  labels:
    stack: local
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteMany
  storageClassName: local-storage
  hostPath:
    path: /var/tmp/polly-safe
...
=end
